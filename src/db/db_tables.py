"""
Database Initialization Module

This module provides functionality for initializing SQLite database tables
for saving chunks in a Retrieval-Augmented Generation (RAG) application.

It handles the creation of:
- chunks table: Stores document chunks with metadata
"""

import logging
import os
import sys
import sqlite3

# Set up the main directory for imports
try:
    MAIN_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../"))
    sys.path.append(MAIN_DIR)
except (ImportError, OSError) as e:
    logging.getLogger(__name__).error("Failed to set up main directory path: %s", e)
    sys.exit(1)

# pylint: disable=wrong-import-position
from src.infra import setup_logging
from src.helpers import get_settings, Settings

logger = setup_logging()
app_settings: Settings = get_settings()


def init_chunks_table(conn: sqlite3.Connection) -> None:
    """
    Initialize the 'chunks' table for storing document chunks and metadata.

    Args:
        conn (sqlite3.Connection): Active SQLite database connection.

    Raises:
        sqlite3.Error: If table creation fails.
    """
    try:
        logger.info("Creating 'chunks' table if it doesn't exist...")

        create_query = """
        CREATE TABLE IF NOT EXISTS chunks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            chunk TEXT NOT NULL,
            file TEXT NOT NULL,
            dataName TEXT NOT NULL
        );
        """
        conn.execute(create_query)
        conn.commit()

        logger.info("'chunks' table created successfully.")

    except sqlite3.Error as e:
        logger.error("Failed to create 'chunks' table: %s", e)
        raise

def init_embed_vector_table(conn: sqlite3.Connection) -> None:
    """
    Initialize the 'embed_vector' table for storing document chunks and their embeddings.

    Table Schema:
        - id: Primary key (auto-incremented)
        - chunk: Raw text of the document chunk
        - embedding: Serialized vector representation (e.g., JSON string or BLOB)
        - chunk_id: Optional logical identifier for the chunk (e.g., UUID or hash)

    Args:
        conn (sqlite3.Connection): Active SQLite database connection.

    Raises:
        sqlite3.Error: If table creation fails.
    """
    try:
        logger.info("Creating 'embed_vector' table if it doesn't exist...")

        create_query = """
        CREATE TABLE IF NOT EXISTS embed_vector (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            chunk TEXT NOT NULL,
            embedding TEXT NOT NULL,
            chunk_id TEXT NOT NULL
        );
        """
        conn.execute(create_query)
        conn.commit()

        logger.info("'embed_vector' table created successfully.")

    except sqlite3.Error as e:
        logger.error("Failed to create 'embed_vector' table: %s", e)
        raise

def init_entitiys_table(conn: sqlite3.Connection) -> None:
    """
    Initialize the 'ner_entities' table in the SQLite database.

    This table stores named entities extracted by the NERModel, including:
    - `id`: Primary key
    - `chunk_id`: Optional external reference ID to link with chunk source
    - `text`: Named entity text (e.g., "Elon Musk")
    - `type`: Entity type (e.g., "PER", "ORG")
    - `start` and `end`: Character indices of the entity within the source text
    - `score`: Confidence score of the model
    - `source_text`: Full original text from which entity was extracted

    Args:
        conn (sqlite3.Connection): The SQLite database connection object.

    Raises:
        sqlite3.Error: If table creation fails.
    """
    try:
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS ner_entities (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                chunk_id TEXT,
                text TEXT NOT NULL,
                type TEXT NOT NULL,
                start INTEGER NOT NULL,
                end INTEGER NOT NULL,
                score REAL NOT NULL,
                source_text TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        conn.commit()
        logger.info("✅ 'ner_entities' table created or already exists.")
    except sqlite3.Error as e:
        logger.exception("❌ Failed to create 'ner_entities' table: %s", e)
        raise

def init_chatbot_table(conn: sqlite3.Connection) -> None:
    """
    Initializes the 'chatbot' table in the SQLite database if it doesn't already exist.

    The table stores user queries, corresponding LLM responses, and retrieval metadata.

    Schema:
        - id (INTEGER): Auto-incrementing primary key.
        - user_id (TEXT): Identifier for the user.
        - query (TEXT): The user's original input query. Cannot be NULL.
        - llm_response (TEXT): The response generated by the LLM. Cannot be NULL.
        - retrieval_context (TEXT): The text content used during retrieval. Cannot be NULL.
        - retrieval_rank (INTEGER): A numerical order/index of the retrieval (e.g., its rank or importance).
        - created_at (TIMESTAMP): Timestamp of record creation, defaults to current timestamp.

    Args:
        conn (sqlite3.Connection): An active SQLite connection.

    Raises:
        sqlite3.Error: If any SQLite-related error occurs during table creation.
    """
    try:
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS chatbot (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id TEXT,
                query TEXT NOT NULL,
                llm_response TEXT NOT NULL,
                retrieval_context TEXT NOT NULL,
                retrieval_rank INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        conn.commit()
        logger.info("✅ 'chatbot' table created or already exists.")
    except sqlite3.Error as e:
        logger.exception("❌ Failed to create 'chatbot' table: %s", e)
        raise


if __name__ == "__main__":
    from src.db import get_sqlite_engine

    conn = get_sqlite_engine()
    if conn:
        logger.info("Initializing the database...")
        try:
            init_chunks_table(conn=conn)
            logger.info("Initialization completed.")
        finally:
            conn.close()
            logger.info("Database connection closed.")
    else:
        logger.error("Database connection failed.")
        sys.exit(1)


