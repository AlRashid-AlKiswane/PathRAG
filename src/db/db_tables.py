"""
Database Retrieval Module.

This module provides a function to retrieve rows from specified SQLite tables,
supporting selective columns and limiting the number of returned rows.

Functions:
- pull_from_table: Fetches data from a given table with optional column selection
  and row limits. Returns results as a list of dictionaries mapping column names
  to their respective values.

Features:
- Uses parameterized queries for dynamic column selection.
- Handles SQLite operational and database errors with detailed logging.
- Logs success and failure events with context.

Usage Example:
    >>> results = pull_from_table(conn, "documents", ["id", "title"], limit=5)
    >>> for row in results:
    ...     print(row["id"], row["title"])
"""

import logging
import os
import sys
import sqlite3

# Set up the main directory for imports
try:
    MAIN_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../"))
    sys.path.append(MAIN_DIR)
except (ImportError, OSError) as e:
    logging.getLogger(__name__).error("Failed to set up main directory path: %s", e)
    sys.exit(1)

# pylint: disable=wrong-import-position
from src.infra import setup_logging
from src.helpers import get_settings, Settings

logger = setup_logging(name="DATABASE-INIT-TABLES")
app_settings: Settings = get_settings()


def init_chunks_table(conn: sqlite3.Connection) -> None:
    """
    Initialize the 'chunks' table for storing document chunks and metadata.

    Args:
        conn (sqlite3.Connection): Active SQLite database connection.

    Raises:
        sqlite3.Error: If table creation fails.
    """
    try:
        logger.info("Creating 'chunks' table if it doesn't exist...")

        create_query = """
        CREATE TABLE IF NOT EXISTS chunks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            chunk TEXT NOT NULL,
            file TEXT NOT NULL,
            dataName TEXT NOT NULL
        );
        """
        conn.execute(create_query)
        conn.commit()

        logger.info("'chunks' table created successfully.")

    except sqlite3.Error as e:
        logger.error("Failed to create 'chunks' table: %s", e)
        raise

def init_embed_vector_table(conn: sqlite3.Connection) -> None:
    """
    Initialize the 'embed_vector' table for storing document chunks and their embeddings.

    Table Schema:
        - id: Primary key (auto-incremented)
        - chunk: Raw text of the document chunk
        - embedding: Serialized vector representation (e.g., JSON string or BLOB)
        - chunk_id: Optional logical identifier for the chunk (e.g., UUID or hash)

    Args:
        conn (sqlite3.Connection): Active SQLite database connection.

    Raises:
        sqlite3.Error: If table creation fails.
    """
    try:
        logger.info("Creating 'embed_vector' table if it doesn't exist...")

        create_query = """
        CREATE TABLE IF NOT EXISTS embed_vector (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            chunk TEXT NOT NULL,
            embedding TEXT NOT NULL,
            chunk_id TEXT NOT NULL
        );
        """
        conn.execute(create_query)
        conn.commit()

        logger.info("'embed_vector' table created successfully.")

    except sqlite3.Error as e:
        logger.error("Failed to create 'embed_vector' table: %s", e)
        raise

def init_chatbot_table(conn: sqlite3.Connection) -> None:
    """
    Initializes the 'chatbot' table in the SQLite database if it doesn't already exist.

    The table stores user queries, corresponding LLM responses, and retrieval metadata.

    Schema:
        - id (INTEGER): Auto-incrementing primary key.
        - user_id (TEXT): Identifier for the user.
        - query (TEXT): The user's original input query. Cannot be NULL.
        - llm_response (TEXT): The response generated by the LLM. Cannot be NULL.
        - retrieval_context (TEXT): The text content used during retrieval. Cannot be NULL.
        - retrieval_rank (INTEGER): A numerical order/index of the retrieval (e.g., its rank or importance).
        - created_at (TIMESTAMP): Timestamp of record creation, defaults to current timestamp.

    Args:
        conn (sqlite3.Connection): An active SQLite connection.

    Raises:
        sqlite3.Error: If any SQLite-related error occurs during table creation.
    """
    try:
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS chatbot (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id TEXT,
                query TEXT NOT NULL,
                llm_response TEXT NOT NULL,
                retrieval_context TEXT NOT NULL,
                retrieval_rank INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        conn.commit()
        logger.info("✅ 'chatbot' table created or already exists.")
    except sqlite3.Error as e:
        logger.exception("❌ Failed to create 'chatbot' table: %s", e)
        raise


if __name__ == "__main__":
    from src.db import get_sqlite_engine

    conn = get_sqlite_engine()
    if conn:
        logger.info("Initializing the database...")
        try:
            init_chunks_table(conn=conn)
            logger.info("Initialization completed.")
        finally:
            conn.close()
            logger.info("Database connection closed.")
    else:
        logger.error("Database connection failed.")
        sys.exit(1)
