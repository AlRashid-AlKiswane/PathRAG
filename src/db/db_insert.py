"""
Database Insert Operations Module.

This module provides functions to insert data into various tables
of the SQLite database used by the application. It includes insertions
for document chunks, embedding vectors, and chatbot interaction records.

Functions:
- insert_chunk: Inserts a document chunk with its source file and data group.
- insert_embed_vector: Inserts a document chunk along with its embedding vector and unique ID.
- insert_chatbot_entry: Records chatbot interactions including user queries,
  LLM responses, retrieval context, and ranking information.

All functions require a valid SQLite connection and perform
robust error handling with transaction rollback on failure.

Logging:
- Successful insertions are logged at INFO level.
- Failures and invalid inputs are logged at ERROR or WARNING levels.
"""

import logging
import os
import sys
import sqlite3

# Set up the main directory for imports
try:
    MAIN_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../"))
    sys.path.append(MAIN_DIR)
except (ImportError, OSError) as e:
    logging.getLogger(__name__).error("Failed to set up main directory path: %s", e)
    sys.exit(1)

# pylint: disable=wrong-import-position
from src.infra import setup_logging

logger = setup_logging(name="DATABASE-INERT")


def insert_chunk(conn: sqlite3.Connection,
                 chunk: str = None,
                 file: str = None,
                 dataName: str = None) -> bool:
    """
    Inserts a document chunk into the 'chunks' table.

    Args:
        conn (sqlite3.Connection): SQLite database connection.
        chunk (str): The text content of the chunk.
        file (str): The file path or name from which the chunk was extracted.
        dataName (str): The source or logical group the chunk belongs to.

    Returns:
        bool: True if insertion was successful, False otherwise.
    """
    try:
        cursor = conn.cursor()
        cursor.execute(
            """
            INSERT INTO chunks (chunk, file, dataName)
            VALUES (:chunk, :file, :dataName)
            """,
            {"chunk": chunk, "file": file, "dataName": dataName}
        )
        conn.commit()
        logger.info("Inserted chunk into 'chunks' table from file: %s", file)
        return True

    except sqlite3.Error as e:
        logger.error("Failed to insert chunk: %s", e)
        conn.rollback()
        return False

def insert_embed_vector(conn: sqlite3.Connection,
                        chunk: str,
                        embedding: str,
                        chunk_id: str) -> bool:
    """
    Inserts a document chunk and its embedding into the 'embed_vector' table.

    Args:
        conn (sqlite3.Connection): SQLite database connection.
        chunk (str): The text content of the document chunk.
        embedding (str): Serialized embedding vector (e.g., JSON string).
        chunk_id (str): Unique identifier for the chunk (e.g., UUID or hash).

    Returns:
        bool: True if insertion was successful, False otherwise.
    """
    try:
        cursor = conn.cursor()
        cursor.execute(
            """
            INSERT INTO embed_vector (chunk, embedding, chunk_id)
            VALUES (:chunk, :embedding, :chunk_id)
            """,
            {"chunk": chunk, "embedding": embedding, "chunk_id": chunk_id}
        )
        conn.commit()
        logger.info("Inserted chunk with chunk_id: %s into 'embed_vector' table.", chunk_id)
        return True

    except sqlite3.Error as e:
        logger.error("Failed to insert into 'embed_vector' table: %s", e)
        conn.rollback()
        return False


def insert_chatbot_entry(conn: sqlite3.Connection,
                         user_id: str = None,
                         query: str = None,
                         llm_response: str = None,
                         retrieval_context: str = None,
                         retrieval_rank: int = None) -> bool:
    """
    Inserts a new entry into the 'chatbot' table.

    Args:
        conn (sqlite3.Connection): SQLite database connection.
        user_id (str): Identifier for the user who made the query (optional).
        query (str): The user's query. Required.
        llm_response (str): The response generated by the LLM. Required.
        retrieval_context (str): The text content used during retrieval. Required.
        retrieval_rank (int): The numerical rank or order of the retrieved context (optional).

    Returns:
        bool: True if insertion was successful, False otherwise.
    """
    try:
        if not query or not llm_response or not retrieval_context:
            logger.warning("Missing required fields: query, llm_response, or retrieval_context.")
            return False

        cursor = conn.cursor()
        cursor.execute(
            """
            INSERT INTO chatbot (user_id, query, llm_response, retrieval_context, retrieval_rank)
            VALUES (:user_id, :query, :llm_response, :retrieval_context, :retrieval_rank)
            """,
            {
                "user_id": user_id,
                "query": query,
                "llm_response": llm_response,
                "retrieval_context": retrieval_context,
                "retrieval_rank": retrieval_rank
            }
        )
        conn.commit()
        logger.info("✅ Inserted chatbot entry for user_id: %s", user_id)
        return True

    except sqlite3.Error as e:
        logger.error("❌ Failed to insert chatbot entry: %s", e)
        conn.rollback()
        return False


if __name__ == "__main__":
    from src.db import get_sqlite_engine

    conn = get_sqlite_engine()
    if conn:
        success = insert_chunk(
            conn=conn,
            chunk="Sample chunk text",
            file="example.pdf",
            dataName="ImmigrationGuide2025"
        )
        logger.info("Insertion success: %s", success)
        conn.close()

